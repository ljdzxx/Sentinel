Java9月8日题：描述一下 JVM 加载 class 文件的原理机制?
参考答案：
JVM 中类的装载是由类加载器（ClassLoader） 和它的子类来实现的，Ja
va 中的类加载器是一个重要的 Java 运行时系统组件，它负责在运行时查找和装
入类文件中的类。
补充：
1.由于 Java 的跨平台性，经过编译的 Java 源程序并不是一个可执行程序，而是
一个或多个类文件。当 Java 程序需要使用某个类时，JVM 会确保这个类已经被
加载、连接(验证、准备和解析)和初始化。类的加载是指把类的.class 文件中的
数据读入到内存中，通常是创建一个字节数组读入.class 文件，然后产生与所加
载类对应的 Class 对象。加载完成后，Class 对象还不完整，所以此时的类还不
可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备(为静态变量分
配内存并设置默认的初始值)和解析(将符号引用替换为直接引用)三个步骤。最后
JVM 对类进行初始化，包括：1 如果类存在直接的父类并且这个类还没有被初
始化，那么就先初始化父类；2 如果类中存在初始化语句，就依次执行这些初始
化语句。

2.类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩
展加载器（Extension）、系统加载器（System）和用户自定义类加载器（jav
a.lang.ClassLoader 的子类）。从 JDK 1.2 开始，类加载过程采取了父亲委托
机制(PDM)。PDM 更好的保证了 Java 平台的安全性，在该机制中，JVM 自带
的 Bootstrap 是根加载器，其他的加载器都有且仅有一个父类加载器。类的加
载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加
载。JVM 不会向 Java 程序提供对 Bootstrap 的引用。下面是关于几个类加载器
的说明：
a)Bootstrap：一般用本地代码实现，负责加载 JVM 基础核心类库（rt.jar）；
b)Extension：从 java.ext.dirs 系统属性所指定的目录中加载类库，它的父加载
器是 Bootstrap；
c)System：又叫应用类加载器，其父类是 Extension。它是应用最广泛的类加
载器。它从环境变量 classpath 或者系统属性 java.class.path 所指定的目录中
记载类，是用户自定义加载器的默认父加载器。

9.9 Redis的过期策略、缓存失效策略？

@redis 过期策略
redis是单线程，收割时间也会占用线程处理时间，如果收割过于频繁，会导致读写出现卡顿。
1、主库过期策略
1.1、定时扫描
首先将每个设置了过期时间的key放到一个独立的hash中，默认每秒定时遍历这个hash而不是整个空间：
并不会遍历所有的key，采用一种简单的贪心策略
1.1.1、从过期key字典中，随机找20个key。
1.1.2、删除20gekey中过期的key
1.1.3、如果2中过期的key超过1/4，则重复第一步
1.1.4、每次处理的时间都不会25ms
如果有大量的key在同一时间段内过期，就会造成数据库的集中访问，就是缓存雪崩！
1.2、惰性策略
客户端访问的时候，会对这个key的过期时间进行检查，如果过期了就立即删除。惰性策略是对定时策略的补充，因为定时策略不会删除所有过期的key
2、从库过期策略
redis不会扫描从库，删除主库数据的时候，在aof文件里生成一条del指令，在主从同步的时候，从库会执行这条指令，删除过期key。
所以集群分布式锁算法的漏洞就是这样产生的。

@常见的几种缓存失效策略 
FIFO ，first in first out ，最先进入缓存的数据在缓存空间不够情况下(超出最大元素限制时)会被首先清理出去
LFU ， Less Frequently Used ，一直以来最少被使用的元素会被被清理掉。这就要求缓存的元素有一个hit 属性，在缓存空间不够得情况下,hit 值最小的将会被清出缓存。
LRU ，Least Recently Used ，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。
